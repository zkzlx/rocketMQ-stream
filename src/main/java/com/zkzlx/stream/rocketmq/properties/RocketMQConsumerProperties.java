package com.zkzlx.stream.rocketmq.properties;

import java.util.HashMap;
import java.util.Map;

import org.apache.rocketmq.client.consumer.AllocateMessageQueueStrategy;
import org.apache.rocketmq.client.consumer.listener.MessageListener;
import org.apache.rocketmq.client.consumer.store.OffsetStore;
import org.apache.rocketmq.common.UtilAll;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;

/**
 * Extended consumer properties for RocketMQ binder.
 *
 * @author zkzlx
 */
public class RocketMQConsumerProperties extends RocketMQCommonProperties {

	/**
	 * Message model defines the way how messages are delivered to each consumer clients.
	 * </p>
	 *
	 * RocketMQ supports two message models: clustering and broadcasting. If clustering is
	 * set, consumer clients with the same {@link #group} would only consume
	 * shards of the messages subscribed, which achieves load balances; Conversely, if the
	 * broadcasting is set, each consumer client will consume all subscribed messages
	 * separately.
	 * </p>
	 *
	 * This field defaults to clustering.
	 */
	private MessageModel messageModel = MessageModel.CLUSTERING;

	/**
	 * Consuming point on consumer booting.
	 * </p>
	 *
	 * There are three consuming points:
	 * <ul>
	 * <li><code>CONSUME_FROM_LAST_OFFSET</code>: consumer clients pick up where it
	 * stopped previously. If it were a newly booting up consumer client, according aging
	 * of the consumer group, there are two cases:
	 * <ol>
	 * <li>if the consumer group is created so recently that the earliest message being
	 * subscribed has yet expired, which means the consumer group represents a lately
	 * launched business, consuming will start from the very beginning;</li>
	 * <li>if the earliest message being subscribed has expired, consuming will start from
	 * the latest messages, meaning messages born prior to the booting timestamp would be
	 * ignored.</li>
	 * </ol>
	 * </li>
	 * <li><code>CONSUME_FROM_FIRST_OFFSET</code>: Consumer client will start from
	 * earliest messages available.</li>
	 * <li><code>CONSUME_FROM_TIMESTAMP</code>: Consumer client will start from specified
	 * timestamp, which means messages born prior to {@link #consumeTimestamp} will be
	 * ignored</li>
	 * </ul>
	 */
	private ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;

	/**
	 * Backtracking consumption time with second precision. Time format is
	 * 20131223171201<br>
	 * Implying Seventeen twelve and 01 seconds on December 23, 2013 year<br>
	 * Default backtracking consumption time Half an hour ago.
	 */
	private String consumeTimestamp = UtilAll
			.timeMillisToHumanString3(System.currentTimeMillis() - (1000 * 60 * 30));

	/**
	 * Queue allocation algorithm specifying how message queues are allocated to each
	 * consumer clients.
	 */
	private AllocateMessageQueueStrategy allocateMessageQueueStrategy;

	/**
	 * Subscription relationship
	 */
	private Map<String /* topic */, String /* sub expression */> subscription = new HashMap<String, String>();

	/**
	 * Message listener
	 */
	private MessageListener messageListener;

	/**
	 * Offset Storage
	 */
	private OffsetStore offsetStore;

	/**
	 * Minimum consumer thread number
	 */
	private int consumeThreadMin = 20;

	/**
	 * Max consumer thread number
	 */
	private int consumeThreadMax = 20;

	/**
	 * Threshold for dynamic adjustment of the number of thread pool
	 */
	private long adjustThreadPoolNumsThreshold = 100000;

	/**
	 * Concurrently max span offset.it has no effect on sequential consumption
	 */
	private int consumeConcurrentlyMaxSpan = 2000;

	/**
	 * Flow control threshold on queue level, each message queue will cache at most 1000
	 * messages by default, Consider the {@code pullBatchSize}, the instantaneous value
	 * may exceed the limit
	 */
	private int pullThresholdForQueue = 1000;

	/**
	 * Limit the cached message size on queue level, each message queue will cache at most
	 * 100 MiB messages by default, Consider the {@code pullBatchSize}, the instantaneous
	 * value may exceed the limit
	 *
	 * <p>
	 * The size of a message only measured by message body, so it's not accurate
	 */
	private int pullThresholdSizeForQueue = 100;

	/**
	 * Flow control threshold on topic level, default value is -1(Unlimited)
	 * <p>
	 * The value of {@code pullThresholdForQueue} will be overwrote and calculated based
	 * on {@code pullThresholdForTopic} if it is't unlimited
	 * <p>
	 * For example, if the value of pullThresholdForTopic is 1000 and 10 message queues
	 * are assigned to this consumer, then pullThresholdForQueue will be set to 100
	 */
	private int pullThresholdForTopic = -1;

	/**
	 * Limit the cached message size on topic level, default value is -1 MiB(Unlimited)
	 * <p>
	 * The value of {@code pullThresholdSizeForQueue} will be overwrote and calculated
	 * based on {@code pullThresholdSizeForTopic} if it is't unlimited
	 * <p>
	 * For example, if the value of pullThresholdSizeForTopic is 1000 MiB and 10 message
	 * queues are assigned to this consumer, then pullThresholdSizeForQueue will be set to
	 * 100 MiB
	 */
	private int pullThresholdSizeForTopic = -1;

	/**
	 * Message pull Interval
	 */
	private long pullInterval = 0;

	/**
	 * Batch consumption size
	 */
	private int consumeMessageBatchMaxSize = 1;

	/**
	 * Batch pull size
	 */
	private int pullBatchSize = 32;

	/**
	 * Whether update subscription relationship when every pull
	 */
	private boolean postSubscriptionWhenPull = false;

	/**
	 * Whether the unit of subscription group
	 */
	private boolean unitMode = false;

	/**
	 * Max re-consume times. -1 means 16 times.
	 * </p>
	 *
	 * If messages are re-consumed more than {@link #maxReconsumeTimes} before success,
	 * it's be directed to a deletion queue waiting.
	 */
	private int maxReconsumeTimes = -1;

	/**
	 * Suspending pulling time for cases requiring slow pulling like flow-control
	 * scenario.
	 */
	private long suspendCurrentQueueTimeMillis = 1000;

	/**
	 * Maximum amount of time in minutes a message may block the consuming thread.
	 */
	private long consumeTimeout = 15;

	/**
	 * Maximum time to await message consuming when shutdown consumer, 0 indicates no
	 * await.
	 */
	private long awaitTerminationMillisWhenShutdown = 0;

}
